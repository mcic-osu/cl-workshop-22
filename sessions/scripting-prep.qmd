---
title: "Variables, Loops, and Conditionals"
highlight-style: oblivion
number-sections: true
---

```{r knitr_options, echo=FALSE}
knitr::opts_chunk$set(eval = FALSE,
                      class.output = "bash-out")
```

-----

:::{.callout-warning}

PAGE STILL UNDER CONSTRUCTION

:::

In this session, we will cover several topics to set the scene for
writing and running shell scripts: variables, `for` loops, and conditionals
(`if` constructs).

<br>

## Before We Get Started

### Goals

- Learn how to use _variables_
- Learn how to use `for` loops to ...
- Learn about "conditionals": `if` constructs to ...

### Setup

1. Log in to OSC at <https://ondemand.osc.edu>.
2. In the blue top bar, select `Interactive Apps` and then `Code Server`.
3. In the form that appears:
   - Enter `3` in the box `Number of hours`
   - Enter `XXX` in the box `Working Directory`
   - Click `Launch`.
4. On the next page, once the top bar of the box has turned green and says `Runnning`,
   click `Connect to VS Code`.
5. Open a terminal by clicking the "hamburger menu" way in the top left,
   and then `Terminal` > `New Terminal`.
6. In the terminal, type `Bash` and press <kbd>Enter</kbd>.

-----

<br>

## Variables

In programming, we use **variables** for things that:

  - We refer to repeatedly and/or
  - Are subject to change.

These tend to be _settings_ like the paths to input and output files,
and parameter values for programs.
(As we'll see, the use of variables also allows us to pass outside information
to a script, so that we can run the same script for different files.)

### Assigning and referencing variables

**To _assign_ a value to a variable in Bash** (in short: to assign a variable),
you use the syntax `variable=value`.
Be aware that there can be no spaces around the equal sign `=`!
For example:

```{bash}
treatment=low

nlines=200
```

**To _reference_ a variable** (i.e., to access its value),
you need to put a dollar sign `$` in front of its name! 
We'll use the `echo` command to see what values our variables holds:

```{bash, echo=TRUE, eval=FALSE}
echo $treatment
```

```{bash, echo=FALSE, eval=TRUE}
treatment=low
echo $treatment
```

```{bash, echo=TRUE, eval=FALSE}
echo $nlines
```

```{bash, echo=FALSE, eval=TRUE}
nlines=200

echo $nlines
```

Conveniently, we can directly use variables in lots of contexts,
as if we had just typed their _values_:

```{bash, eval=TRUE}
ls_options="-lh"

ls $ls_options
```

```{bash, eval=TRUE}
input_file=shell-scripting.qmd

ls -lh $input_file 
```

### Rules for naming variables

Variable names:

- Can contain letters, numbers, and underscores
- Cannot contain spaces, periods, or other special symbols
- Cannot start with a number

### Command substitution

If you want to store the result of a command in a variable,
you can use a construct called "**command substitution**"
by wrapping the command inside `$()`:

```{bash, eval=TRUE}
today=$(date +%F)

touch README_$today.txt
ls README_*
```

```{bash, eval=TRUE}
input_file=shell-scripting.qmd

nlines=$(wc -l < $input_file)

echo "The file $input_file has $nlines lines"
```

Command substitution can for instance be useful when you want your script
to report some results,
or when a next step in the script depends on a previous result.

### Environment variables

There are also predefined variables in the Unix shell:
that is, variables that exist in your environment by default.
These so-called "environment variables" are always in all-caps:

```{bash, eval=TRUE}
# Environment variable $USER contains your user name 
echo $USER
```

```{bash, eval=TRUE}
# Environment variable $HOME contains the path to your home directory
echo $HOME
```

Environment variables can provide useful information.
We'll see them again when we talk about the `SLURM` compute job scheduler.

### Quoting variables

What happens if the value of our variable contains spaces?

First off, when we try to _assign_ the variable without quotes,
we get an error:

```{bash, eval=FALSE, error=TRUE}
today=Thu, Aug 18
#> Aug: command not found
```

But it works when we quote the entire string that makes up the value:

```{bash, eval=TRUE}
today="Thu, Aug 18"
echo $today
```

Now, let's try to _reference_ the variable with spaces:

```{bash, eval=FALSE}
touch README2_$today.txt
ls README2_*
```

```{bash, eval=TRUE, echo=FALSE}
today="Thu, Aug 18"
touch README2_$today.txt
ls README2_*
```

Oops! The shell performed _field splitting_ on the spaces to split the value
into three separate units &ndash;
as a result, three files were created:
`README2_Thu,` (listed above), as well as `Aug` and `18.txt` (not shown).

Similar to what we had to do when assigning the variable,
problems can be avoided by **quoting the variable** when we reference it:

```{bash, eval=FALSE}
touch README3_"$today".txt
ls README3_*
```

```{bash, eval=TRUE, echo=FALSE}
today="Thu, Aug 18"
touch README3_"$today".txt
ls README3_*
```

Another issue we can run into when we don't quote variables
is that we can't explicitly define where a variable name ends
within a longer string of text:

```{bash, eval=FALSE}
echo README_$today_final.txt
```

```{bash, eval=TRUE, echo=FALSE}
today="Thu, Aug 18"
echo README_$today_final.txt
```

:::{.callout-note collapse="true"}
## What is going wrong here?

- Following a `$`, the shell will stop interpreting characters as being part
  of the variable name only when it encounters a character that cannot be
  part of a variable name, such as a space or a period.

- Since variable names _can_ contain underscores, it will look for the variable
  `$today_final`, which does not exist.
  
- Importantly, the shell **does not error out** when you reference a
  non-existing variable -- it basically ignores it,
  such that `README_$today_final.txt` becomes `README_.txt`,
  as if we hadn't referenced any variable.

:::

Quoting solves this issue, too:

```{bash, eval=FALSE}
echo README_"$today"_final.txt
```

```{bash, eval=TRUE, echo=FALSE}
today="Thu, Aug 18"
echo README_"$today"_final.txt
```

:::{.callout-tip}

All in all, **it is good practice to quote variables** when you reference them:
it never hurts and avoids unexpected surprises.

:::

<br>

## For loops

Loops are a universal element of programming languages,
and are extremely useful to repeat operations,
such as when you want to run the same script or command for multiple files.

**Here, we'll only cover what is by far the most common type of loop:
the `for` loop.**

`for` loops _iterate_ over a collection, such as a list of files:
that is, they allow you to perform one or more actions for each element in the collection, one element at a time.

### `for` loop syntax and mechanics

Let's see a first example, where our collection is just a list of numbers:

```{bash, eval=TRUE}
for a_number in 1 2 3; do
    echo "In this iteration of the loop, the number is $a_number"
    echo "--------"
done
```

`for` loops contain the following mandatory keywords:

| Keyword   | Purpose	
|-----------|-------------
| `for`	    | After `for`, we set the variable name	
| `in`	    | After `in`, we specify the collection we are looping over	
| `do`	    | After `do`, we have one ore more lines specifying what to do with each item	
| `done`	  | Tells the shell we are done with the loop


:::{.callout-note collapse="true"}
## Why the semicolon `;` before `do`?

A semicolon separates two commands written on a single line --
for instance, instead of:

```{bash, eval=FALSE}
mkdir results
cd results
```

...you could equivalently type:

```{bash, eval=FALSE}
mkdir results; cd results
```

The `;` in the `for` loop syntax has the same function, and as such,
an alternative way to format a `for` loop is:

```{bash, eval=FALSE}
for a_number in 1 2 3
do
    echo "In this iteration of the loop, the number is $a_number"
done
```

But that's one line longer and a bit awkwardly asymmetric.

:::

It is important to realize that the loop runs sequentially for each item
in the collection, and will therefore run as many times as there are items
in the collection.

The following example, where we let the computer sleep for 1 second
before printing the date and time with the `date` command,
demonstrates that the loop is being executed sequentially:

```{bash, eval=TRUE}
for a_number in 1 2 3; do
    echo "In this iteration of the loop, the number is $a_number"
    sleep 1s          # Let the computer sleep for 1 second
    date              # Print the date and time
    echo "--------"
done
```

The aspect that is perhaps most difficult to understand is that in each iteration
of the loop, one element in the collection (in the example above, either `1`,
`2`, or `3`) _is being assigned_ to the variable specified after `for`
(in the example above, `a_number`).

When we specify the collection "manually", like we did above with numbers,
we separate the elements by a space, as this example also shows:

```{bash, eval=TRUE}
for mushroom in morel destroying_angel eyelash_cup; do
    echo "$mushroom is an Ohio mushroom"
done
```

### Looping over files with globbing

In practice, we rarely manually list the collection of items we want to
loop over.
Instead, we commonly **loop over files** directly using _globbing_: 

```{bash, eval=FALSE}
for fastq_file in data/raw/*fastq.gz; do
    echo "File $fastq_file has $(wc -l < $fastq_file) lines."
    # More processing...
done
```

:::{.callout-note collapse="true"}
## Bonus: Bash arrays and looping over them

Bash arrays are like lists in Python or vectors in R,
and can be created using parentheses `()`.

- Create an array manually:

  ```sh
  $ sample_names=(zmaysA zmaysB zmaysC)
  ```

- Create an array using command substitution:

  ```sh
  $ sample_files=($(cut -f 3 samples.txt))
  
  $ sample_files=($(cat fastq_files.txt))
  ```

- Using `[@]`, we can access all elements in the array:

  ```sh
  $ echo ${sample_names[@]}  # Print all elements in the array
  #> zmaysA zmaysB zmaysC
  ```

- Arrays are mostly useful to loop over,
  and we can also use the `[@]` notation to loop over the elements:

  ```sh
  $ for sample_name in "${sample_names[@]}"; do
        echo "$sample_name"
      done
  #> zmaysA zmaysB zmaysC
  ```

```{bash, eval=FALSE}
for sample_name in "${sample_names[@]}"; do
    echo "Processing sample $sample_name"
    input_file="$sample_name"_R1.fastq
    # More processing...
done
```

:::

<br>

## Conditionals

TBA

```{bash, eval=TRUE, echo=FALSE}
rm README* 18.txt Aug
```
